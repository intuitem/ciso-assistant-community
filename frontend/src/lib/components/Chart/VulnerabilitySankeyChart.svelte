<script lang="ts">
	import { onMount } from 'svelte';
	import { safeTranslate } from '$lib/utils/i18n';

	interface Props {
		width?: string;
		height?: string;
		classesContainer?: string;
		title?: string;
		name?: string;
		sankeyData: any[];
	}

	let {
		width = 'w-auto',
		height = 'h-full',
		classesContainer = '',
		title = '',
		name = 'vulnerability_sankey',
		sankeyData = []
	}: Props = $props();

	// Define severity order (-- can be in both severity and status)
	const severityOrder = ['--', 'undefined', 'info', 'low', 'medium', 'high', 'critical'];
	const statusOrder = [
		'potential',
		'exploitable',
		'mitigated',
		'fixed',
		'not_exploitable',
		'unaffected',
		'--'
	];

	// Extract unique nodes from links and categorize them based on their position in the flow
	function extractNodes(links: any[]) {
		// Identify which nodes are sources and targets
		const allSources = new Set<string>();
		const allTargets = new Set<string>();

		links.forEach((link) => {
			allSources.add(link.source);
			allTargets.add(link.target);
		});

		// Domains: nodes that are sources but never targets (first column)
		const domains = Array.from(allSources).filter((node) => !allTargets.has(node));

		// Statuses: nodes that are targets but never sources (last column)
		const statuses = Array.from(allTargets).filter((node) => !allSources.has(node));

		// Severities: nodes that are both sources and targets (middle column)
		const severities = Array.from(allSources).filter((node) => allTargets.has(node));

		// Sort severities by defined order
		severities.sort((a, b) => {
			const aIndex = severityOrder.indexOf(a.toLowerCase());
			const bIndex = severityOrder.indexOf(b.toLowerCase());
			return aIndex - bIndex;
		});

		// Sort statuses by defined order
		statuses.sort((a, b) => {
			const aIndex = statusOrder.indexOf(a.toLowerCase());
			const bIndex = statusOrder.indexOf(b.toLowerCase());
			return aIndex - bIndex;
		});

		// Combine in order: domains, severities (sorted), statuses
		const sortedNodes = [...domains, ...severities, ...statuses];

		return sortedNodes.map((name) => ({ name }));
	}

	const chart_id = `${name}_div`;

	onMount(async () => {
		if (!sankeyData || sankeyData.length === 0) return;

		const echarts = await import('echarts');
		let chart = echarts.init(document.getElementById(chart_id), null, { renderer: 'svg' });

		const nodes = extractNodes(sankeyData);

		// Identify which nodes are sources and targets to determine their column
		const allSources = new Set<string>();
		const allTargets = new Set<string>();
		sankeyData.forEach((link) => {
			allSources.add(link.source);
			allTargets.add(link.target);
		});

		// Assign explicit depths and positions to nodes to control ordering
		const nodesWithDepth = nodes.map((node, index) => {
			const nodeName = node.name;
			const nodeLower = nodeName.toLowerCase();
			let depth = 0;
			let itemStyle: any = {};

			// Determine depth based on link relationships
			if (!allTargets.has(nodeName)) {
				// Source only = Domain (first column)
				depth = 0;
			} else if (!allSources.has(nodeName)) {
				// Target only = Status (last column)
				depth = 2;
			} else {
				// Both source and target = Severity (middle column)
				depth = 1;
				// Assign colors by severity
				const severityColors: Record<string, string> = {
					critical: '#dc2626',
					high: '#ea580c',
					medium: '#ca8a04',
					low: '#2563eb',
					info: '#64748b',
					undefined: '#475569',
					'--': '#475569'
				};
				itemStyle = { color: severityColors[nodeLower] || '#94a3b8' };
			}

			return { ...node, depth, itemStyle };
		});

		const option = {
			title: {
				text: title,
				left: 'center',
				textStyle: {
					fontSize: 16,
					fontWeight: 'bold'
				}
			},
			tooltip: {
				trigger: 'item',
				triggerOn: 'mousemove'
			},
			series: {
				type: 'sankey',
				layout: 'none',
				orient: 'horizontal',
				nodeAlign: 'left',
				layoutIterations: 0,
				emphasis: {
					focus: 'adjacency'
				},
				data: nodesWithDepth,
				links: sankeyData,
				lineStyle: {
					color: 'gradient',
					curveness: 0.5
				},
				label: {
					formatter: (params: any) => {
						// Translate severity and status labels
						return safeTranslate(params.name);
					}
				}
			}
		};

		chart.setOption(option);

		const resizeHandler = function () {
			chart.resize();
		};

		window.addEventListener('resize', resizeHandler);

		// Cleanup function
		return () => {
			chart.dispose();
			window.removeEventListener('resize', resizeHandler);
		};
	});
</script>

<div
	id={chart_id}
	class="{height} {width} {classesContainer}"
	style="width: 100%; height: 100%;"
></div>
