import type { Locator, Expect } from '@playwright/test';
import { Page } from './page';

/** This is a fundamental class, it must be inherited by any base/derived class that represents an HTML element. */
export class Element {
	static DATA_TESTID: string = '';
	protected _self: Locator;

	private _page: Page;
	private _chain: Element[];
	private _context: Element.Context;

	/**
	 * Creates an Element instance.
	 *
	 * @param elem - The Playwright Locator for this Element.
	 * @param superElement - The super-element of this Element.
	 * @param elemContext - An optional context for this Element.
	 */
	constructor(
		elem: Locator,
		superElement: Element.SuperElement,
		elemContext: Element.Context = {}
	) {
		this._self = elem;
		this._page = Element._getIsPage(superElement) ? superElement : superElement._page;
		this._chain = Element._getNewChain(superElement);
		this._context = elemContext;
	}

	private static _getNewChain(superElement: Element.SuperElement): Element[] {
		// @ts-ignore: This will be the only time the _chain property is accessed by another Element.
		return Element._getIsPage(superElement) ? [] : [...superElement._chain, superElement];
	}

	private static _getIsPage(superElement: Element.SuperElement): superElement is Page {
		let currentProto = Object.getPrototypeOf(superElement);
		let nextProto = Object.getPrototypeOf(currentProto);
		while (nextProto.constructor !== Object) {
			currentProto = nextProto;
			nextProto = Object.getPrototypeOf(nextProto);
		}
		// currentProto represents the last non-null Prototype
		// In this context the last non-null Prototype is the first javascript Base class which is always a fundamental class (Element or Page) according to the spec.
		return currentProto.constructor.name === 'Page';
	}

	/** Get the Page which directly/indirectly accessed this object. */
	protected _getPage(): Page {
		return this._page;
	}

	/**
	 * Get the super-element chain of this element.
	 *
	 * Note: A chain [A, B, C] means that:
	 * - A is the super-element which generated this element.
	 * - B is the super-element which generated A.
	 * - C is the super-element which generated B.
	 * - C has been directly generated by a Page object.
	 *
	 * If the chain is empty it means that this element has been accessed by a Page.
	 * Therefore it doesn't have any Element super-elements, the only super-element is the page object itself.
	 * */
	protected _getChain(): Element[] {
		return this._chain;
	}

	/**
	 * Retrieves a context value associated with the specified key by searching through multiple context sources.
	 *
	 * The method checks for the value in the following order:
	 * 1. The current element's `_context` property.
	 * 2. The static `CONTEXT` property on the current element's constructor.
	 * 3. Each element in the chain's `_context` property and static `CONTEXT` property.
	 * 4. The static `CONTEXT` property on the page instance (`_page`).
	 *
	 * The function returns the first defined value found for the given key. If no value is found, it returns `undefined`.
	 *
	 * @template K - The key type within the `Element.Context` interface.
	 * @param key - The key for which to retrieve the corresponding context value.
	 * @returns The value of type `Element.Context[K]` associated with the provided key, or `undefined` if not found.
	 */
	protected _getContext<K extends keyof Element.Context>(
		key: keyof Element.Context
	): Element.Context[K] {
		let contextValue = this._context[key];
		if (contextValue !== undefined) {
			return contextValue;
		}
		// @ts-ignore: We don't care if CONTEXT is defined or not, as it's handled by the ?? operator.
		contextValue = (this.constructor.CONTEXT ?? {})[key];
		if (contextValue !== undefined) {
			return contextValue;
		}

		for (let i = this._chain.length - 1; i >= 0; i--) {
			const superElement = this._chain[i];
			contextValue = superElement._context[key];
			if (contextValue !== undefined) {
				return contextValue;
			}

			// @ts-ignore: We don't care if CONTEXT is defined or not, as it's handled by the ?? operator.
			contextValue = (superElement.constructor.CONTEXT ?? {})[key];
			if (contextValue !== undefined) {
				return contextValue;
			}
		}

		// @ts-ignore: We don't care if CONTEXT is defined or not, as it's handled by the ?? operator.
		return (this._page.constructor.CONTEXT ?? {})[key];
	}

	/**
	 * Determines if the context contains a defined value for the specified key.
	 *
	 * Note: A key with a value of undefined is considered non-existing.
	 *
	 * @param key - The context key to check.
	 * @returns True if the context value exists, false otherwise.
	 */
	protected _getHasContext(key: keyof Element.Context): boolean {
		return this._getContext(key) !== undefined;
	}

	/** Returns the Locator that this object represents. */
	getSelf(): Locator {
		return this._self;
	}

	async checkIfVisible(expect: Expect): Promise<void> {
		await expect(this._self).toBeVisible();
	}

	/**
	 * Retrieves a sub-element instance of the specified element class, applying locator filters and optionally passing it a context.
	 *
	 * @template T - The type of the Element class to instantiate.
	 * @param elementClass - The constructor of the Element class, which must have a static `DATA_TESTID` property.
	 * @param filters - Optional locator filters used to refine the element selection. Defaults to an empty object.
	 * @param context - Optional context to be passed to the element instance. Defaults to an empty object.
	 * @param page - Reserved solely for internal use by the Page._getSubElement method.
	 * @returns A new instance of the specified element class (`InstanceType<T>`).
	 *
	 * @throws If the static `DATA_TESTID` property is missing on the provided element class.
	 *
	 * @remarks
	 * This method extracts a data test identifier from either the provided filters or the static `DATA_TESTID` property
	 * of the element class. It uses this identifier to obtain a locator, then applies additional filters (like `nth`, `first`,
	 * or `last`) to narrow down the element selection. Finally, it instantiates the element class with the resolved locator, the super-element (`this`) and the context.
	 */
	protected _getSubElement<T extends Element.Class<any>>(
		elementClass: T,
		filters: Element.LocatorFilters = {},
		context: Element.Context = {},
		page: Page | null = null
	): InstanceType<T> {
		const dataTestId = filters.dataTestId || elementClass.DATA_TESTID;
		// Should i really check if this property is undefined ?
		// After all typescript should reveal if the class is missing this property when using this method.
		if (!dataTestId) {
			throw new Error(
				`Missing required static string property 'DATA_TESTID' in class '${elementClass.name}'.`
			);
		}
		let locator = this._self.getByTestId(dataTestId);
		if (['has', 'hasNot', 'hasNotText', 'hasText'].some((key) => filters[key])) {
			locator = locator.filter(filters); // I guess invalid filters will be ignored.
		}

		if (filters.nth) {
			locator = locator.nth(filters.nth);
		} else if (filters.first) {
			locator = locator.first();
		} else if (filters.last) {
			locator = locator.last();
		}

		const superElement = page ? page : this;
		return new elementClass(locator, superElement, context);
	}

	/** Print the super-element chain of the element with all its non-empty context sources. */
	doShowContextChain() {
		console.log(
			`[Super-Element Chain] len=${this._chain.length} ${this._chain.map((obj, index) => {
				`[${index}] ${obj.constructor.name}`;
			})}`
		);
		const printContext = (name, context) =>
			console.log(`[${name}] ${JSON.stringify(context, null, 2)}`);

		if (this._context) {
			printContext('this._context', this._context);
		}
		// @ts-ignore
		if (this.constructor.CONTEXT) {
			// @ts-ignore
			printContext('this.constructor.CONTEXT', this.constructor.CONTEXT);
		}

		for (let i = this._chain.length - 1; i >= 0; i--) {
			const superElement = this._chain[i];
			if (superElement._context) {
				printContext(`chain[${i}].context`, superElement._context);
			}
			// @ts-ignore
			if (superElement.constructor.CONTEXT) {
				// @ts-ignore
				printContext(`chain[${i}].constructor.CONTEXT`, superElement.constructor.CONTEXT);
			}
		}

		// @ts-ignore
		if (this._page.constructor.CONTEXT) {
			// @ts-ignore
			printContext('this._page.constructor.CONTEXT', this._page.constructor.CONTEXT);
		}
	}

	/**
	 * Log out the element in the browser's console.
	 * This can be usefull to visually see where the element is in the browser while coding.
	 */
	async doShow(): Promise<void> {
		this._self.evaluate((self) => {
			console.log(`[${self.getAttribute('data-testid')}]`, self);
		});
		// this._self.highlight(); // This doesn't work for whatever reason.
	}
}
export namespace Element {
	/**
	 * @template T - The base class of the Element class this type represents.
	 * This type represents an Element class which is usefull for methods that accept an Element class as a parameter.
	 */
	export type Class<T> = (new (
		locator: Locator,
		superElement: Element.SuperElement,
		context?: Element.Context
	) => T) & { DATA_TESTID: string };

	/**
	 * This represents the context of an element (see in the spec)
	 * All Element's constructor have an optional Element.Context that can be passed to it.
	 * */
	export interface Context {
		URLModel?: string;
	}

	/** This represents a super-element, which is either a Page or an Element. */
	export type SuperElement = Page | Element;

	/** This structure is used to refine element selection when using the Element _getSubElement protected method. */
	export interface LocatorFilters {
		// The dataTestId parameter may be usefull if we ever want to use the same Element class for 2 different Test IDs.
		dataTestId?: string;
		nth?: number;
		first?: boolean;
		last?: boolean;
		has?: Locator;
		hasNot?: Locator;
		hasNotText?: string | RegExp;
		hasText?: string | RegExp;
	}

	/** This type represents the list of arguments passed to the Element's constructor. */
	export type Args = [Locator, SuperElement, Context?];
}
