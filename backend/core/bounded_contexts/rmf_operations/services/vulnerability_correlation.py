"""
Vulnerability Correlation Service

Service for correlating vulnerabilities between STIG checklists (CKL) and
Nessus ACAS vulnerability scans. Provides unified vulnerability management
and comprehensive risk assessment.
"""

import uuid
import logging
from typing import Dict, List, Any, Optional, Tuple
from difflib import SequenceMatcher

logger = logging.getLogger(__name__)


class VulnerabilityCorrelationService:
    """
    Service for correlating vulnerabilities between different sources.

    Correlates CKL checklist findings with Nessus scan results to provide
    comprehensive vulnerability management and unified risk assessment.
    """

    def __init__(self):
        """Initialize the correlation service"""
        self.correlation_thresholds = {
            'high_confidence': 0.9,    # 90%+ match confidence
            'medium_confidence': 0.7,  # 70%+ match confidence
            'low_confidence': 0.5      # 50%+ match confidence
        }

    def correlate_checklist_with_nessus(
        self,
        checklist_id: uuid.UUID,
        nessus_scan_id: uuid.UUID
    ) -> Dict[str, Any]:
        """
        Correlate vulnerabilities between a STIG checklist and Nessus scan.

        Args:
            checklist_id: UUID of the STIG checklist
            nessus_scan_id: UUID of the Nessus scan

        Returns:
            Dict containing correlation results
        """
        # Get checklist findings
        checklist_findings = self._get_checklist_findings(checklist_id)
        if not checklist_findings:
            return self._create_empty_correlation_result(checklist_id, nessus_scan_id)

        # Get Nessus findings
        nessus_findings = self._get_nessus_findings(nessus_scan_id)
        if not nessus_findings:
            return self._create_empty_correlation_result(checklist_id, nessus_scan_id)

        # Perform correlation
        correlations = []
        unmatched_ckl = []
        unmatched_nessus = list(nessus_findings)  # Copy for tracking

        for ckl_finding in checklist_findings:
            matches = self._find_nessus_matches(ckl_finding, nessus_findings)

            if matches:
                # Remove matched Nessus findings from unmatched list
                for match in matches:
                    nessus_finding = match['nessus_finding']
                    if nessus_finding in unmatched_nessus:
                        unmatched_nessus.remove(nessus_finding)

                correlations.append({
                    'ckl_finding': ckl_finding,
                    'matches': matches,
                    'correlation_confidence': max(m['confidence'] for m in matches),
                    'best_match': matches[0]  # Highest confidence match
                })
            else:
                unmatched_ckl.append(ckl_finding)

        # Update scan with correlation
        self._update_scan_correlation(nessus_scan_id, checklist_id)

        return {
            'checklist_id': str(checklist_id),
            'nessus_scan_id': str(nessus_scan_id),
            'total_ckl_findings': len(checklist_findings),
            'total_nessus_findings': len(nessus_findings),
            'correlations_found': len(correlations),
            'unmatched_ckl_findings': len(unmatched_ckl),
            'unmatched_nessus_findings': len(unmatched_nessus),
            'correlation_coverage': len(correlations) / max(len(checklist_findings), 1),
            'correlations': correlations,
            'unmatched_ckl': unmatched_ckl,
            'unmatched_nessus': unmatched_nessus,
            'summary': self._generate_correlation_summary(correlations, unmatched_ckl, unmatched_nessus)
        }

    def _find_nessus_matches(self, ckl_finding: Dict[str, Any],
                           nessus_findings: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Find matching Nessus findings for a CKL finding.

        Uses multiple correlation methods:
        1. CVE matching (highest confidence)
        2. Plugin name similarity
        3. Vulnerability ID patterns
        """
        matches = []

        for nessus_finding in nessus_findings:
            correlation_result = self._correlate_single_finding(ckl_finding, nessus_finding)

            if correlation_result['confidence'] >= self.correlation_thresholds['low_confidence']:
                matches.append({
                    'nessus_finding': nessus_finding,
                    'confidence': correlation_result['confidence'],
                    'match_type': correlation_result['match_type'],
                    'match_details': correlation_result['details']
                })

        # Sort by confidence (highest first)
        matches.sort(key=lambda x: x['confidence'], reverse=True)

        # Return only top matches to avoid noise
        return matches[:3]

    def _correlate_single_finding(self, ckl_finding: Dict[str, Any],
                                nessus_finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Correlate a single CKL finding with a Nessus finding.

        Returns correlation result with confidence score and match details.
        """
        # Method 1: CVE matching (highest confidence)
        cve_confidence = self._correlate_by_cve(ckl_finding, nessus_finding)
        if cve_confidence['confidence'] >= self.correlation_thresholds['high_confidence']:
            return cve_confidence

        # Method 2: Plugin name similarity
        name_confidence = self._correlate_by_name_similarity(ckl_finding, nessus_finding)
        if name_confidence['confidence'] >= self.correlation_thresholds['medium_confidence']:
            return name_confidence

        # Method 3: Vulnerability ID patterns
        id_confidence = self._correlate_by_vuln_id(ckl_finding, nessus_finding)
        if id_confidence['confidence'] > name_confidence['confidence']:
            return id_confidence

        # Return best match
        best_match = max([cve_confidence, name_confidence, id_confidence],
                        key=lambda x: x['confidence'])

        return best_match

    def _correlate_by_cve(self, ckl_finding: Dict[str, Any],
                         nessus_finding: Dict[str, Any]) -> Dict[str, Any]:
        """Correlate by CVE references"""
        ckl_cves = set()
        nessus_cves = set(nessus_finding.get('cve', []))

        # Extract CVEs from CKL finding (may be in various fields)
        for field in ['cve', 'discussion', 'check_content']:
            content = ckl_finding.get(field, '')
            if content:
                # Simple CVE extraction (can be enhanced)
                import re
                cves = re.findall(r'CVE-\d{4}-\d{4,}', content, re.IGNORECASE)
                ckl_cves.update(cve.upper() for cve in cves)

        # Find intersection
        common_cves = ckl_cves.intersection(nessus_cves)

        if common_cves:
            confidence = min(1.0, len(common_cves) * 0.5 + 0.5)  # High confidence for CVE matches
            return {
                'confidence': confidence,
                'match_type': 'cve',
                'details': f"Common CVEs: {', '.join(common_cves)}"
            }

        return {
            'confidence': 0.0,
            'match_type': 'cve',
            'details': 'No CVE matches found'
        }

    def _correlate_by_name_similarity(self, ckl_finding: Dict[str, Any],
                                    nessus_finding: Dict[str, Any]) -> Dict[str, Any]:
        """Correlate by plugin/vulnerability name similarity"""
        ckl_name = ckl_finding.get('rule_title', '').lower()
        nessus_name = nessus_finding.get('plugin_name', '').lower()

        if not ckl_name or not nessus_name:
            return {
                'confidence': 0.0,
                'match_type': 'name_similarity',
                'details': 'Missing name data'
            }

        # Calculate similarity ratio
        similarity = SequenceMatcher(None, ckl_name, nessus_name).ratio()

        # Boost confidence if key security terms match
        security_terms = ['password', 'encryption', 'authentication', 'access', 'privilege']
        ckl_has_security = any(term in ckl_name for term in security_terms)
        nessus_has_security = any(term in nessus_name for term in security_terms)

        if ckl_has_security and nessus_has_security:
            similarity = min(1.0, similarity + 0.2)

        return {
            'confidence': similarity,
            'match_type': 'name_similarity',
            'details': f"Name similarity: {similarity:.2%}"
        }

    def _correlate_by_vuln_id(self, ckl_finding: Dict[str, Any],
                             nessus_finding: Dict[str, Any]) -> Dict[str, Any]:
        """Correlate by vulnerability ID patterns"""
        ckl_vuln_id = ckl_finding.get('vuln_id', '')
        nessus_plugin_id = str(nessus_finding.get('plugin_id', ''))

        # Look for numerical ID patterns
        ckl_numbers = ''.join(c for c in ckl_vuln_id if c.isdigit())
        nessus_numbers = ''.join(c for c in nessus_plugin_id if c.isdigit())

        if ckl_numbers and nessus_numbers and ckl_numbers == nessus_numbers:
            return {
                'confidence': 0.8,  # High confidence for ID matches
                'match_type': 'vulnerability_id',
                'details': f"Matching ID numbers: {ckl_numbers}"
            }

        return {
            'confidence': 0.0,
            'match_type': 'vulnerability_id',
            'details': 'No ID pattern matches'
        }

    def _get_checklist_findings(self, checklist_id: uuid.UUID) -> List[Dict[str, Any]]:
        """Get findings from a STIG checklist"""
        try:
            from ..repositories.vulnerability_finding_repository import VulnerabilityFindingRepository
            repo = VulnerabilityFindingRepository()
            return list(repo.find_by_checklist(checklist_id))
        except Exception as e:
            logger.error(f"Error getting checklist findings: {e}")
            return []

    def _get_nessus_findings(self, nessus_scan_id: uuid.UUID) -> List[Dict[str, Any]]:
        """Get findings from a Nessus scan"""
        try:
            from ..repositories.nessus_scan_repository import NessusScanRepository
            repo = NessusScanRepository()
            scan = repo.get_by_id(nessus_scan_id)
            if scan and hasattr(scan, 'vulnerabilities'):
                return scan.vulnerabilities
        except Exception as e:
            logger.error(f"Error getting Nessus findings: {e}")
        return []

    def _update_scan_correlation(self, nessus_scan_id: uuid.UUID, checklist_id: uuid.UUID):
        """Update scan with checklist correlation"""
        try:
            from ..repositories.nessus_scan_repository import NessusScanRepository
            repo = NessusScanRepository()
            scan = repo.get_by_id(nessus_scan_id)
            if scan:
                scan.add_correlation(checklist_id)
                repo.save(scan)
        except Exception as e:
            logger.error(f"Error updating scan correlation: {e}")

    def _create_empty_correlation_result(self, checklist_id: uuid.UUID,
                                       nessus_scan_id: uuid.UUID) -> Dict[str, Any]:
        """Create result for correlation with no data"""
        return {
            'checklist_id': str(checklist_id),
            'nessus_scan_id': str(nessus_scan_id),
            'total_ckl_findings': 0,
            'total_nessus_findings': 0,
            'correlations_found': 0,
            'unmatched_ckl_findings': 0,
            'unmatched_nessus_findings': 0,
            'correlation_coverage': 0.0,
            'correlations': [],
            'unmatched_ckl': [],
            'unmatched_nessus': [],
            'summary': {
                'status': 'no_data',
                'message': 'No findings data available for correlation'
            }
        }

    def _generate_correlation_summary(self, correlations: List[Dict],
                                    unmatched_ckl: List[Dict],
                                    unmatched_nessus: List[Dict]) -> Dict[str, Any]:
        """Generate summary statistics for correlation results"""
        high_confidence = sum(1 for c in correlations if c['correlation_confidence'] >= 0.9)
        medium_confidence = sum(1 for c in correlations if 0.7 <= c['correlation_confidence'] < 0.9)
        low_confidence = sum(1 for c in correlations if 0.5 <= c['correlation_confidence'] < 0.7)

        return {
            'high_confidence_matches': high_confidence,
            'medium_confidence_matches': medium_confidence,
            'low_confidence_matches': low_confidence,
            'total_unmatched_ckl': len(unmatched_ckl),
            'total_unmatched_nessus': len(unmatched_nessus),
            'correlation_quality': 'excellent' if high_confidence > medium_confidence else 'good' if medium_confidence > low_confidence else 'needs_review',
            'recommendations': self._generate_recommendations(correlations, unmatched_ckl, unmatched_nessus)
        }

    def _generate_recommendations(self, correlations: List[Dict],
                                unmatched_ckl: List[Dict],
                                unmatched_nessus: List[Dict]) -> List[str]:
        """Generate recommendations based on correlation results"""
        recommendations = []

        if len(unmatched_ckl) > len(correlations) * 0.5:
            recommendations.append("High number of unmatched CKL findings - consider manual review")

        if len(unmatched_nessus) > len(correlations) * 0.3:
            recommendations.append("Significant unmatched Nessus findings - may indicate coverage gaps")

        low_confidence = sum(1 for c in correlations if c['correlation_confidence'] < 0.7)
        if low_confidence > len(correlations) * 0.2:
            recommendations.append("Many low-confidence correlations - review matching algorithms")

        if not recommendations:
            recommendations.append("Correlation results look good - findings are well-matched")

        return recommendations

    def get_correlation_statistics(self, checklist_id: Optional[uuid.UUID] = None,
                                 nessus_scan_id: Optional[uuid.UUID] = None) -> Dict[str, Any]:
        """Get correlation statistics across all or specific scans"""
        # Implementation for retrieving correlation stats
        # This would query the correlation data
        return {
            'total_correlations': 0,
            'average_confidence': 0.0,
            'correlation_distribution': {},
            'top_unmatched_findings': []
        }
