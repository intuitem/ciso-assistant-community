"""
VulnerabilityFinding Repository

Repository for VulnerabilityFinding aggregates.
"""

from typing import Optional, List, Dict
import uuid
from django.http import HttpRequest

from core.domain.repository import BaseRepository
from ..aggregates.vulnerability_finding import VulnerabilityFinding
from ..services.audit_service import audit_service


class VulnerabilityFindingRepository(BaseRepository[VulnerabilityFinding]):
    """
    Repository for VulnerabilityFinding aggregates.

    Provides methods for querying and managing vulnerability findings.
    """

    def __init__(self):
        super().__init__(VulnerabilityFinding)

    def find_by_checklist(self, checklist_id: uuid.UUID) -> List[VulnerabilityFinding]:
        """Find all findings for a checklist"""
        return list(VulnerabilityFinding.objects.filter(checklistId=checklist_id))

    def find_by_vuln_id(self, vuln_id: str) -> List[VulnerabilityFinding]:
        """Find findings by vulnerability ID across all checklists"""
        return list(VulnerabilityFinding.objects.filter(vulnId=vuln_id))

    def find_open_findings(self) -> List[VulnerabilityFinding]:
        """Find all open findings"""
        return list(VulnerabilityFinding.objects.filter(status_data__status='open'))

    def find_findings_by_status(self, status: str) -> List[VulnerabilityFinding]:
        """Find findings by status"""
        return list(VulnerabilityFinding.objects.filter(status_data__status=status))

    def find_findings_by_severity(self, severity_category: str) -> List[VulnerabilityFinding]:
        """Find findings by severity category"""
        return list(VulnerabilityFinding.objects.filter(severity_category=severity_category))

    def find_high_severity_open_findings(self) -> List[VulnerabilityFinding]:
        """Find high severity (CAT I) open findings"""
        return list(VulnerabilityFinding.objects.filter(
            severity_category='cat1',
            status_data__status='open'
        ))

    def find_findings_with_overrides(self) -> List[VulnerabilityFinding]:
        """Find findings that have severity overrides"""
        return list(VulnerabilityFinding.objects.exclude(status_data__severity_override__isnull=True))

    def find_findings_by_stig_id(self, stig_id: str) -> List[VulnerabilityFinding]:
        """Find findings by STIG ID"""
        return list(VulnerabilityFinding.objects.filter(stigId=stig_id))

    def count_findings_by_status(self, checklist_id: Optional[uuid.UUID] = None) -> Dict[str, int]:
        """Count findings by status, optionally filtered by checklist"""
        queryset = VulnerabilityFinding.objects.all()
        if checklist_id:
            queryset = queryset.filter(checklistId=checklist_id)

        counts = {}
        for status in ['open', 'not_a_finding', 'not_applicable', 'not_reviewed']:
            counts[status] = queryset.filter(status_data__status=status).count()

        return counts

    def count_findings_by_severity_and_status(self, checklist_id: Optional[uuid.UUID] = None) -> Dict[str, Dict[str, int]]:
        """Count findings by severity and status"""
        queryset = VulnerabilityFinding.objects.all()
        if checklist_id:
            queryset = queryset.filter(checklistId=checklist_id)

        result = {
            'cat1': {},
            'cat2': {},
            'cat3': {}
        }

        for severity in ['cat1', 'cat2', 'cat3']:
            severity_queryset = queryset.filter(severity_category=severity)
            for status in ['open', 'not_a_finding', 'not_applicable', 'not_reviewed']:
                result[severity][status] = severity_queryset.filter(
                    status_data__status=status
                ).count()

        return result

    def search_findings(self, query: str, checklist_id: Optional[uuid.UUID] = None) -> List[VulnerabilityFinding]:
        """Search findings by vulnerability ID, rule title, or STIG ID"""
        queryset = VulnerabilityFinding.objects.filter(
            vulnId__icontains=query
        ) | VulnerabilityFinding.objects.filter(
            ruleTitle__icontains=query
        ) | VulnerabilityFinding.objects.filter(
            stigId__icontains=query
        )

        if checklist_id:
            queryset = queryset.filter(checklistId=checklist_id)

        return list(queryset.distinct())

    def bulk_update_status(self, finding_ids: List[uuid.UUID],
                          new_status: str,
                          finding_details: Optional[str] = None,
                          comments: Optional[str] = None,
                          user_id: Optional[uuid.UUID] = None,
                          username: Optional[str] = None,
                          request: Optional[HttpRequest] = None) -> int:
        """Bulk update status for multiple findings with audit logging"""
        findings = list(VulnerabilityFinding.objects.filter(id__in=finding_ids))
        finding_names = [f"{finding.vulnId} ({finding.ruleTitle})" for finding in findings]

        updated_count = 0
        for finding in findings:
            old_status = finding.status_data.status
            finding.update_status(new_status, finding_details, comments)
            finding.save()

            # Individual audit logging if user context provided
            if user_id and username:
                audit_service.log_operation(
                    user_id=user_id,
                    username=username,
                    action_type='bulk_update',
                    entity_type='vulnerability_finding',
                    entity_id=finding.id,
                    entity_name=f"{finding.vulnId}: {finding.ruleTitle}",
                    request=request,
                    old_values={'status': old_status},
                    new_values={
                        'status': new_status,
                        'finding_details': finding_details,
                        'comments': comments
                    }
                )

            updated_count += 1

        # Bulk audit logging summary
        if user_id and username and findings:
            audit_service.log_operation(
                user_id=user_id,
                username=username,
                action_type='bulk_update',
                entity_type='vulnerability_finding',
                entity_id=findings[0].id,  # Use first finding as representative
                entity_name=f"Bulk update of {len(findings)} findings",
                request=request,
                old_values=None,
                new_values={
                    'operation': 'bulk_status_update',
                    'new_status': new_status,
                    'finding_details': finding_details,
                    'comments': comments,
                    'affected_findings': len(findings)
                }
            )

        return updated_count

    def get_findings_for_bulk_update(self, checklist_id: uuid.UUID,
                                    status_filter: str = 'not_reviewed') -> List[VulnerabilityFinding]:
        """Get findings that can be bulk updated (typically 'not_reviewed')"""
        return list(VulnerabilityFinding.objects.filter(
            checklistId=checklist_id,
            status_data__status=status_filter
        ))

    def get_finding_stats_for_checklist(self, checklist_id: uuid.UUID) -> Dict[str, int]:
        """Get statistics for findings in a checklist"""
        counts = self.count_findings_by_severity_and_status(checklist_id)

        # Flatten to simple totals
        total_open = sum(cat_data['open'] for cat_data in counts.values())
        total_not_a_finding = sum(cat_data['not_a_finding'] for cat_data in counts.values())
        total_not_applicable = sum(cat_data['not_applicable'] for cat_data in counts.values())
        total_not_reviewed = sum(cat_data['not_reviewed'] for cat_data in counts.values())

        return {
            'total_open': total_open,
            'total_not_a_finding': total_not_a_finding,
            'total_not_applicable': total_not_applicable,
            'total_not_reviewed': total_not_reviewed,
            'total_findings': total_open + total_not_a_finding + total_not_applicable + total_not_reviewed,
            'details': counts
        }

    def get_findings_with_cci_references(self, cci_id: str) -> List[VulnerabilityFinding]:
        """Find findings that reference a specific CCI"""
        return list(VulnerabilityFinding.objects.filter(cciIds__contains=[cci_id]))

    def get_recent_findings(self, days: int = 7) -> List[VulnerabilityFinding]:
        """Get findings updated within the last N days"""
        from django.utils import timezone
        from datetime import timedelta

        cutoff_date = timezone.now() - timedelta(days=days)
        return list(VulnerabilityFinding.objects.filter(updated_at__gte=cutoff_date))

    def get_findings_by_effective_severity(self, severity: str) -> List[VulnerabilityFinding]:
        """Get findings by effective severity (accounting for overrides)"""
        # This is more complex as it needs to account for overrides
        # For now, return by base severity - overrides would need custom logic
        return list(VulnerabilityFinding.objects.filter(severity_category=severity.lower()))
